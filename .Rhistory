level_shock_length = 1,
vol_shock_length = 10,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 2,
arch_param = c(.2),
garch_param = c(.7),
level_model = c('M1','M2','none')[2],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = 10,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 2,
arch_param = c(.2),
garch_param = c(.7),
level_model = c('M1','M2','none')[1],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = 10,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 2,
arch_param = c(.2),
garch_param = c(.7),
level_model = c('M1','M2','none')[3],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = 10,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 2,
arch_param = c(.2),
garch_param = c(.7),
level_model = c('M1','M2','none')[3],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = 1,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
# David Lundquist
# Simulations for Synthetic Prediction GARCH
library(quantmod)
library(garchx)
library(lmtest)
library(extraDistr)
library(gnorm)
library(tsDyn)
library(Rsolnp)
options(scipen = 6)
synth_vol_sim <- function(n,
p,
arch_param,
garch_param,
level_model,
vol_model,
sigma_GARCH_innov,
sigma_x,
shock_time_vec,
level_shock_length,
vol_shock_length,
a,
b,
mu_eps_star,
M22_mu_eps_star,
sigma_eps_star,
mu_omega_star,
M22_mu_omega_star,
vol_shock_sd,
level_GED_alpha,
level_GED_beta,
...){
## Doc String
# synth_vol_sim: function that simulates (n+1)*(p+1) time series:
# a response series and p covariate series for each of the n donors
# and for the time series under study, as well.  The series
# must experience an exogenous shock at exactly one discrete time point
# in the series.
# --Input:
#   --n - number of donors (scalar)
#   --p - number of covariates (scalar)
#   --arch parameters (vector of length 0 or more)
#   --garch parameters (vector of length 0 or more)
#   --level_model - model for level of the shock (string)
#   --vol_model - model for volatility of the shock (string)
#   --sigma_GARCH_innov (scalar)
#   --sigma_x - sigma of innovations in covariates (scalar)
#   --shock_time_vec - optional input to force shock times (vector of integers)
#   --level_shock_length (scalar)
#   --vol_shock_length (scalar)
#   --a - minumum series length (scalar)
#   --b - maximum series length (scalar)
#   --mu_eps_star - intercept of level shock for M1 model
#   --M22_mu_eps_star - intercept of level shock for M22 model
#   --sigma_eps_star - variance of level shock for all level shocks
#   --mu_omega_star - intercept of vol shock for M1 model
#   --M22_mu_omega_star - intercept of vol shock for M22 model
#   --vol_shock_sd - variance of level shock for all vol shocks
#   --level_GED_alpha - alpha parameter for level shock stochastic term
#   --level_GED_beta - beta parameter for level shock stochastic term
#Simulate series lengths
Tee <- rdunif(n+1, a, b)
#Before we simulate shock time, we make sure each series has enough points
#following the shock time
max_of_shock_lengths <- max(level_shock_length, vol_shock_length)
warnings('Each series has shock ', 5)
# Simulate shock times
if ( is.null(shock_time_vec) == TRUE)
{
shock_time_vec <- c()
for (i in 1:(n+1))
{
#Note: the T* must be at least 'max_of_shock_lengths' after T*
#Also, shock must come from point 30 onward.
shock_time_vec[i] <- rdunif(1, 30, Tee[i]-max_of_shock_lengths)
}
}
############ Simulate Structure of Covariates ############
# Now generate the covariates.  These will be correlated GARCH processes, ideally.
# Since multivariate GARCH processes take take technical care to simulate, we first use VAR.
# https://math.stackexchange.com/questions/1529000/how-to-create-a-random-matrix-whose-spectral-radius-1
#Random parameters for the VAR
param_matrix_entries <- runif(p**2, min = -1/p, max = 1/p)
simVAR_params <- matrix(param_matrix_entries, nrow = p, byrow = T)
#Note: In our meeting on Jan 12, 2022, Dan Eck and I discussed the justification for fixing
#a common Phi matrix for all of the n+1 series.  By fixing a common Phi matrix,
#we're basically saying that that each covariate has the same structure across all donors.
#For example, WTI and VIX behave the same way for Lehmann 2008 as they do for
#Russia-Saudi-OPEC 2014.  We might want to relax this at some point by partitioning the n
#donors into k sets and saying that the n donors are temporally clustered that way,
#Doing it this way would imitate the way that Lin and Eck 2021 COP donors fall into
#the sets Spring 2008, Fall 2008, Spring 2014.
############ Simulate all n+1 series   ############
#Create null lists for depvar and indepvar output
Y <- vector(mode = "list", length = n+1)
X <- vector(mode = "list", length = n+1)
level_shock_vec <- c()
vol_shock_vec <- c()
T_star_plus_1_return_vec <- c()
xreg <- vector(mode = "list", length = n+1)
# For each of n+1 series...
for (i in 1:(n+1)){
#Epsilon vector for the VAR
innovations_matrix_entries <- rnorm(Tee[i] * p, sd = sigma_x)
sim_VAR_innovations <- matrix(innovations_matrix_entries, ncol = p, byrow = T)
VAR_process <- VAR.sim(B = simVAR_params,
lag = 1,
include = "none",
n = Tee[i],
innov = sim_VAR_innovations) + 1 #we add this constant to make the
#covariates positive
#Level model
if (level_model == 'M1'){
#Level Shock
level_shock_vec[i] <- mu_eps_star + # This is the non-stochastic term
rgnorm(1,
mu = 0,
alpha = level_GED_alpha,
beta = level_GED_beta) # This is the stochastic term
level_shock_mean <- mu_eps_star
level_shock_var <- ((level_GED_alpha)**2) * gamma(3/level_GED_beta) / (gamma(1/level_GED_beta)) # https://search.r-project.org/CRAN/refmans/gnorm/html/gnorm.html
}
else if (level_model == 'M22') {
level_shock_vec[i] <- mu_eps_star +
as.numeric(as.matrix(VAR_process[shock_time_vec[i],])) %*% rnorm(p,M22_mu_eps_star,sigma_eps_star) +
rgnorm(1,
mu = 0,
alpha = level_GED_alpha,
beta = level_GED_beta) #What's the variance of this sum?
level_shock_mean <- mu_eps_star
level_shock_var <- ((level_GED_alpha)**2) * gamma(3/level_GED_beta) / (gamma(1/level_GED_beta)) + # https://search.r-project.org/CRAN/refmans/gnorm/html/gnorm.html
(sigma_x**2) * (sigma_eps_star**2)
}
else {level_shock_vec[i] <- rnorm(1, 0, sigma_GARCH_innov); level_shock_mean <- 0; level_shock_var <- sigma_GARCH_innov**2}
#Vol model
if (vol_model == 'M1'){
#Create volatility shock w*
vol_shock_vec[i] <- rnorm(1, mu_omega_star, vol_shock_sd)
vol_shock_mean <- mu_omega_star
vol_shock_var <- vol_shock_sd**2
shock_indicator <- c(
rep(0, shock_time_vec[i]),
rep(vol_shock_vec[i], vol_shock_length),
rep(0, Tee[i] - shock_time_vec[i] - vol_shock_length))
#Now add the design matrix to the list X
X[[i]] <- cbind(VAR_process, shock_indicator)
#Create GARCH model with shock(s)
GARCH_innov_vec <- c(
rnorm(shock_time_vec[i], 0, sigma_GARCH_innov),
level_shock_vec[i],
rnorm(Tee[i] - shock_time_vec[i] - 1, 0, sigma_GARCH_innov))
Y[[i]] <- garchxSim(Tee[i], arch = arch_param, garch = garch_param,
xreg =  as.matrix( X[[i]][,(p+1)] ),
innovations = GARCH_innov_vec, verbose = TRUE)
}
else if (vol_model == 'M22') {
vol_shock_vec[i] <- rnorm(1, mu_omega_star, vol_shock_sd)
as.numeric(as.matrix(VAR_process[shock_time_vec[i],])) %*% rnorm(p,M22_mu_omega_star,sigma_eps_star)
#What's the variance of this sum?
vol_shock_mean <- mu_omega_star
vol_shock_var <- vol_shock_sd**2 + (sigma_x**2) * (sigma_eps_star**2)
shock_indicator <- c(
rep(0, shock_time_vec[i]),
rep(vol_shock_vec[i], vol_shock_length),
rep(0, Tee[i] - shock_time_vec[i] - vol_shock_length))
#Now add the design matrix to the list X
X[[i]] <- cbind(VAR_process, shock_indicator)
#Create GARCH model with shock(s)
GARCH_innov_vec <- c(
rnorm(shock_time_vec[i], 0, sigma_GARCH_innov),
level_shock_vec[i],
rnorm(Tee[i] - shock_time_vec[i] - 1, 0, sigma_GARCH_innov))
Y[[i]] <- garchxSim(Tee[i], arch = arch_param, garch = garch_param,
xreg =  as.matrix( X[[i]][,(p+1)] ),
innovations = GARCH_innov_vec, verbose = TRUE)
}
else {
#Create volatility shock w*
vol_shock_vec[i] <- rnorm(1, 0, sigma_GARCH_innov)
vol_shock_mean <- 0
vol_shock_var <- 0
#Now add the design matrix to the list X
X[[i]] <- cbind(VAR_process)
#Create GARCH model with shock(s)
GARCH_innov_vec <- rnorm(Tee[i], 0, sigma_GARCH_innov)
Y[[i]] <- garchxSim(Tee[i], arch = arch_param, garch = garch_param,
innovations = GARCH_innov_vec, verbose = TRUE)
} #end conditionals that create vol shocks
T_star_plus_1_return_vec[i] <- Y[[i]][,1][shock_time_vec[i]+1,]
#Now we calculate the p-value for the volatility spike of length k
indicator_vec <- as.matrix(c(rep(0,shock_time_vec[i]), rep(1,k)))
garch_1_1 <- garchx(Y[[i]][1:(shock_time_vec[i]+k),1], order = c(1,1), xreg = indicator_vec[1:(shock_time_vec[i]+k)])
xreg_est <- round(coeftest(garch_1_1)[ dim(coeftest(garch_1_1))[1], 1],5)
xreg_p_value <- round(coeftest(garch_1_1)[ dim(coeftest(garch_1_1))[1], dim(coeftest(garch_1_1))[2]],5)
xreg[[i]] <- c(xreg_est, xreg_p_value)
} #end loop for n+1 series
## Compute summary statistics for output
level_shock_kurtosis <- gamma(5/level_GED_beta)*gamma(1/level_GED_beta)/( (gamma(3/level_GED_beta))**2 ) - 3 #https://en.wikipedia.org/wiki/Generalized_normal_distribution
vol_shock_kurtosis <- -9999
T_star_sigma <- Y[[1]][,3][shock_time_vec[1],]
T_star_plus_1_sigma <- Y[[1]][,3][shock_time_vec[1]+1,]
T_star_plus_2_sigma <- Y[[1]][,3][shock_time_vec[1]+2,]
T_star_plus_3_sigma <- Y[[1]][,3][shock_time_vec[1]+3,]
##Output
cat('Simulation Summary Data','\n',
'-------------------------------------------------------------\n',
'Donors:', n, '\n',
'Series lengths:', Tee, '\n',
'Shock times:', shock_time_vec, '\n',
'Level Shock at T*+1:', round(level_shock_vec,2), '\n',
'T*+1: Return:', round(T_star_plus_1_return_vec,3), '\n',
'Volatility Shock at T*+1', round(vol_shock_vec,2), '\n',
'\n',
'Volatility of Time Series under Study', '\n',
'-------------------------------------------------------------\n',
'Sigma^2 at T*:', round(T_star_sigma,2), '\n',
'Sigma^2 at T*+1:', round(T_star_plus_1_sigma,2), '\n',
'Sigma^2 at T*+2:', round(T_star_plus_2_sigma,2), '\n',
'Sigma^2 at T*+3:', round(T_star_plus_3_sigma,2), '\n',
'\n',
'Level Shock Moments', '\n',
'-------------------------------------------------------------\n',
'Level Shock mean:', round(level_shock_mean,4), '(equivalent to a', round(100*level_shock_mean,2), '% daily move).', ' \n',
'Level Shock variance:', round(level_shock_var,4), '\n',
'Level Signal to Noise:', abs(round(level_shock_mean / sqrt(level_shock_var),2)) , '\n',
'Level Shock excess kurtosis:', round(level_shock_kurtosis, 2) , '\n',
'\n',
'Vol Shock Moments', '\n',
'-------------------------------------------------------------\n',
'Vol Shock mean:', round(vol_shock_mean,2), ' \n',
'Vol Shock variance:', round(vol_shock_var,4), '\n',
'Vol Signal to Noise:', abs(round(vol_shock_mean / sqrt(vol_shock_var),3)) , '\n',
'Vol Shock excess kurtosis:', round(vol_shock_kurtosis, 2)
)
#Plot the donors
par(mfrow = c(ceiling(sqrt(2*n + 2)), ceiling(sqrt(2*n + 2))))
for (i in 1:(n+1))
{
plot.ts(X[[i]][-c(1:20),], main = paste('Covariates of Donor ', i, sep = ''))
}
#Plot the time series
par(mfrow = c(ceiling(sqrt(n+1)), ceiling(sqrt(n+1))))
for (i in 1:(n+1))
{
plot.ts(Y[[i]][,1], ylim = c(min(Y[[i]][,1])*1.2, max(Y[[i]][,1])*1.2),
main = paste('y_', i, ", GARCH(",arch_param,",",garch_param,")",
"\n level shock = ",
round( level_shock_vec[i],2),
", vol shock = ",
round(vol_shock_vec[i],2),
'\n shock est = ', xreg[[i]][1], ', pval = ',xreg[[i]][2],
sep = ''), ylab = 'Daily Log-Return')
abline(v = shock_time_vec[i] + 1, col = 'red')
abline(h = 0, col = 'green')
}
#Plot the volatility series
par(mfrow = c(ceiling(sqrt(n+1)), ceiling(sqrt(n+1))))
for (i in 1:(n+1))
{
plot.ts(Y[[i]][-c(1:20),3], xlim=c(21, Tee[i]), main = paste('Volatility Series of y_', i,
", GARCH(",arch_param,",",garch_param,")",
"\n level shock = ",
round( level_shock_vec[i],2),
", vol shock = ",
round(vol_shock_vec[i],2),
'\n shock est = ', xreg[[i]][1], ', pval = ',xreg[[i]][2],
sep = ''), ylab = 'Sigma^2')
abline(v = shock_time_vec[i] + 1, col = 'red')
}
#Items to return in a list
return(list(X,Y,Tee,shock_time_vec))
}
# Here is the length of the vol shock we used
k <- 2
output <- synth_vol_sim(n = 8,
p = 6,
arch_param = c(.41),
garch_param = c(.39),
level_model = c('M1','M21','M22','none')[1],
vol_model = c('M1','M21','M22','none')[3],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = k,
a = 90,
b = 150,
mu_eps_star = -.0625,
M22_mu_eps_star = .3,
sigma_eps_star = .01,
mu_omega_star = .6,
M22_mu_omega_star = 4,
vol_shock_sd = .1,
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 6,
arch_param = c(.41),
garch_param = c(.39),
level_model = c('M1','M21','M22','none')[4],
vol_model = c('M1','M21','M22','none')[3],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = k,
a = 90,
b = 150,
mu_eps_star = -.0625,
M22_mu_eps_star = .3,
sigma_eps_star = .01,
mu_omega_star = .6,
M22_mu_omega_star = 4,
vol_shock_sd = .1,
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
sqrt(.00001)
output <- synth_vol_sim(n = 8,
p = 6,
arch_param = c(.41),
garch_param = c(.39),
level_model = c('M1','M21','M22','none')[3],
vol_model = c('M1','M21','M22','none')[3],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = k,
a = 90,
b = 150,
mu_eps_star = -.0625,
M22_mu_eps_star = .3,
sigma_eps_star = .01,
mu_omega_star = .6,
M22_mu_omega_star = 4,
vol_shock_sd = .1,
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 6,
arch_param = c(.41),
garch_param = c(.39),
level_model = c('M1','M21','M22','none')[3],
vol_model = c('M1','M21','M22','none')[3],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = k,
a = 90,
b = 150,
mu_eps_star = -.0625,
M22_mu_eps_star = .2,
sigma_eps_star = .01,
mu_omega_star = .6,
M22_mu_omega_star = 4,
vol_shock_sd = .1,
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 6,
arch_param = c(.41),
garch_param = c(.39),
level_model = c('M1','M21','M22','none')[3],
vol_model = c('M1','M21','M22','none')[3],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = k,
a = 90,
b = 150,
mu_eps_star = -.0625,
M22_mu_eps_star = .05,
sigma_eps_star = .01,
mu_omega_star = .6,
M22_mu_omega_star = 4,
vol_shock_sd = .1,
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 6,
arch_param = c(.41),
garch_param = c(.39),
level_model = c('M1','M21','M22','none')[3],
vol_model = c('M1','M21','M22','none')[3],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = k,
a = 90,
b = 150,
mu_eps_star = -.0625,
M22_mu_eps_star = .01,
sigma_eps_star = .01,
mu_omega_star = .6,
M22_mu_omega_star = 4,
vol_shock_sd = .1,
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
