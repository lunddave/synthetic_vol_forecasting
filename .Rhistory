garch_param = c(.21),
level_model = c('M1','M2','none')[3],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.005), # this is the sd that goes into rnorm
sigma_x = .0005,
shock_time_vec = NULL,
length_of_shock = 1,
a = 90,
b = 150,
mu_eps_star = -.0825,
sigma_eps_star = .0005,
mu_omega_star = .72,
vol_shock_multiplier = 3,
vol_shock_sd = .3,
omega_shape = .2,
omega_rate = 2,
level_GED_alpha = .05 * sqrt( 2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 5,
p = 2,
arch_param = c(.55),
garch_param = c(.44),
level_model = c('M1','M2','none')[3],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.005), # this is the sd that goes into rnorm
sigma_x = .0005,
shock_time_vec = NULL,
length_of_shock = 1,
a = 90,
b = 150,
mu_eps_star = -.0825,
sigma_eps_star = .0005,
mu_omega_star = .72,
vol_shock_multiplier = 3,
vol_shock_sd = .3,
omega_shape = .2,
omega_rate = 2,
level_GED_alpha = .05 * sqrt( 2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 5,
p = 2,
arch_param = c(.55),
garch_param = c(.44),
level_model = c('M1','M2','none')[1],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.005), # this is the sd that goes into rnorm
sigma_x = .0005,
shock_time_vec = NULL,
length_of_shock = 1,
a = 90,
b = 150,
mu_eps_star = -.0825,
sigma_eps_star = .0005,
mu_omega_star = .72,
vol_shock_multiplier = 3,
vol_shock_sd = .3,
omega_shape = .2,
omega_rate = 2,
level_GED_alpha = .05 * sqrt( 2),
level_GED_beta = 1.8)
## 'PAYEMS' is the Federal Reserve of St. Louis' name for the monthly employment figure,
## (i.e. the number of persons employed in the US, in thousands)
## a time series that goes back to the 1950s.
### In this file, we produce two simple kinds output:
# (1) a set of shock times
# (2) a large matrix of data indexed by month, where the index
# includes the shock times as a proper subset
#significant digits
options(scipen = 7)
# load packages (not all of these may be necessary)
library("data.table")
library("dplyr")
library("tseries")
library("quantmod")
library('Rsolnp')
library('msos')
library('tikzDevice')
library('xtable')
# load packages
require('forecast')
## Time series under study: # persons on nonfarm payrolls
getSymbols("PAYEMS", src = 'FRED')
###          COVARIATES            ###
###           START                ###
## https://fred.stlouisfed.org/series/W825RC1: transfer receipts
getSymbols("W825RC1", src = 'FRED')
## https://fred.stlouisfed.org/series/RPI: real personal income
getSymbols("RPI", src = 'FRED')
## https://fred.stlouisfed.org/series/PCE: Personal Consumption Expenditures
getSymbols("PCE", src = 'FRED')
## https://fred.stlouisfed.org/series/INDPRO: Industrial Production
getSymbols("INDPRO", src = 'FRED')
## https://fred.stlouisfed.org/series/CPIAUCSL: Consumer Price Index
getSymbols("CPIAUCSL", src = 'FRED')
## https://fred.stlouisfed.org/series/FEDFUNDS: Consumer Price Index
getSymbols("FEDFUNDS", src = 'FRED')
## https://fred.stlouisfed.org/series/LNS12000031: Black Employment Count
getSymbols("LNS12000031", src = 'FRED')
###          COVARIATES          ###
###             END              ###
### CONSTRUCTION OF THE DONOR POOL ###
###           START                ###
#https://www.federalreservehistory.org/essays/oil-shock-of-1973-74
#https://www.federalreservehistory.org/essays/recession-of-1981-82
#credit-control program initiated in March 1980 by the Carter administration
#https://www.history.com/news/us-economic-recessions-timeline
#https://fred.stlouisfed.org/series/FEDFUNDS#0
# As a rule, when the shock occurs mid-month, we take that to be the shock-time, even though
# the shock effect is distributed across that month as well as the following month(s)
shock_time_vec <- c('1957-04-01', ##Flu hits US
'1958-08-01', ## Fed Funds rate increases from .68 to 1.53 in one month
'1973-10-01', ## OAPEC oil embargo begins
'1980-03-01', ## program announced on March 14th by Carter
'2001-09-01', ## 9/11 attacks occur 1/3 of way into month
'2020-03-01') ## COVID shutdown - included in the time series of interest
# These are all T* points not T*+1.
### CONSTRUCTION OF THE DONOR POOL ###
###           END                  ###
## Now, we take the outcome variable and covariates and smash them into a
## large matrix, including lags of the covariates.
datasets <- list(W825RC1, RPI, PCE, INDPRO, CPIAUCSL, FEDFUNDS, LNS12000031)
df <- PAYEMS
for (i in 1:length(datasets)) {df <- merge(df, datasets[[i]])}
# Hit every column with the differenced-log transformation
difflog_df <- data.frame(diff(as.matrix(log(df))))
# We create lags of the covariates
# https://stackoverflow.com/questions/38119225/debugging-function-to-create-multiple-lags-for-multiple-columns-dplyr
difflog_df.lag <- shift(difflog_df, n=1:2, give.names = T)  ##column indexes of columns to be lagged as "[,startcol:endcol]", "n=1:3" specifies the number of lags (lag1, lag2 and lag3 in this case)
# We we combine and original series and the lags
merged <- bind_cols(difflog_df, difflog_df.lag)
#Now add the row names
row.names(merged) <- row.names(difflog_df)
# We do not need any rows prior to 1954-07-01
merged <- merged[row.names(merged) >= '1954-07-01', ]
#Now, due to the release date for each of these monthly series,
#we unfortunately cannot use the same-month data points for some of
#these columns.  We now drop them...
merged <- subset(merged, select = -c(W825RC1,
RPI,
PCE,
INDPRO,
CPIAUCSL,
LNS12000031))
#Finally, we have missing data in the late 1950s, so we are faced with a choice:
#(1) We can drop all rows with NA entries, which will remove the 1950s donors.
complete_cases_merged <- merged[complete.cases(merged),]
paste('This is a dataset of dimension', dim(complete_cases_merged)[1], 'by', dim(complete_cases_merged)[2])
#(2) We can drop all columns with NA values, which will drop some covariates, but keep all 5 donors.
no_NA_cols_merged <- merged[ , colSums(is.na(merged)) == 0]
paste('This is a dataset of dimension', dim(no_NA_cols_merged)[1], 'by', dim(no_NA_cols_merged)[2])
# And we're done!  Either of the two datasets above will work.  It's a question of whether we
# want 5 donors with fewer covariates, or fewer donors with more covariates.
complete_cases_merged
head(complete_cases_merged)
View(complete_cases_merged)
complete_cases_merged <- merged[complete.cases(merged),]
paste('This is a dataset of dimension', dim(complete_cases_merged)[1], 'by', dim(complete_cases_merged)[2])
#(2) We can drop all columns with NA values, which will drop some covariates, but keep all 5 donors.
no_NA_cols_merged <- merged[ , colSums(is.na(merged)) == 0]
paste('This is a dataset of dimension', dim(no_NA_cols_merged)[1], 'by', dim(no_NA_cols_merged)[2])
complete_cases_merged
# David Lundquist
# Simulations for Synthetic Prediction GARCH
library(quantmod)
library(garchx)
library(lmtest)
library(extraDistr)
library(gnorm)
library(tsDyn)
library(Rsolnp)
options(scipen = 6)
## Doc String
# synth_vol_sim: function that simulates (n+1)*(p+1) time series:
# a response series and p covariate series for each of the n donors
# and for the time series under study, as well.  The series
# must experience an exogenous shock at exactly one discrete time point
# in the series.
# --Input:
#   --n
#   --p
#   --model for the shock (M1, M2)
#   --sigma of the shock
#   --shock time vector (if specified by user. Otherwise, simulated.)
#   -- a,b, the parameters used to construct the discrete uniform from which we get series lengths
synth_vol_sim <- function(n, p, arch_param, garch_param,
level_model,
vol_model,
sigma_GARCH_innov, sigma_x,
shock_time_vec,
level_shock_length,
vol_shock_length,
a, b,
mu_eps_star, M2_mu_eps_star, sigma_eps_star,
mu_omega_star, M2_mu_omega_star, vol_shock_multiplier,
vol_shock_sd,
omega_shape, omega_rate,
level_GED_alpha,
level_GED_beta,
...){
#Simulate series lengths
Tee <- rdunif(n+1, a, b)
#Before we simulate shock time, we make sure each series has enough points
#following the shock time
max_of_shock_lengths <- max(level_shock_length, vol_shock_length)
warnings('Each series has shock ', 5)
# Simulate shock times
if ( is.null(shock_time_vec) == TRUE)
{
shock_time_vec <- c()
for (i in 1:(n+1))
{
#Note: the T* must be at least 'max_of_shock_lengths' after T*
#Also, shock must come from point 30 onward.
shock_time_vec[i] <- rdunif(1, 30, Tee[i]-max_of_shock_lengths)
}
}
############ Simulate Structure of Covariates ############
# Now generate the covariates.  These will be correlated GARCH processes, ideally.
# Since multivariate GARCH processes take take technical care to simulate, we first use VAR.
# https://math.stackexchange.com/questions/1529000/how-to-create-a-random-matrix-whose-spectral-radius-1
#Random parameters for the VAR
param_matrix_entries <- runif(p**2, min = -1/p, max = 1/p)
simVAR_params <- matrix(param_matrix_entries, nrow = p, byrow = T)
############ Simulate all n+1 series   ############
#Create null lists for depvar and indepvar output
Y <- vector(mode = "list", length = n+1)
X <- vector(mode = "list", length = n+1)
level_shock_vec <- c()
vol_shock_vec <- c()
T_star_plus_1_return_vec <- c()
# For each of n+1 series...
for (i in 1:(n+1)){
#Epsilon vector for the VAR
innovations_matrix_entries <- rnorm(Tee[i] * p, sd = sigma_x)
sim_VAR_innovations <- matrix(innovations_matrix_entries, ncol = p, byrow = T)
VAR_process <- VAR.sim(B = simVAR_params,
lag = 1,
include = "none",
n = Tee[i],
innov = sim_VAR_innovations) + 1
#Level model
if (level_model == 'M1'){
#Level Shock
level_shock_vec[i] <- mu_eps_star + # This is the non-stochastic term
rgnorm(1,
mu = 0,
alpha = level_GED_alpha,
beta = level_GED_beta) # This is the stochastic term
level_shock_mean <- mu_eps_star
level_shock_var <- ((level_GED_alpha)**2) * gamma(3/level_GED_beta) / (gamma(1/level_GED_beta)) # https://search.r-project.org/CRAN/refmans/gnorm/html/gnorm.html
}
else if (level_model == 'M2') {
level_shock_vec[i] <- mu_eps_star +
as.numeric(as.matrix(VAR_process[shock_time_vec[i],])) %*% rnorm(p,M2_mu_eps_star,sigma_eps_star) +
rgnorm(1,
mu = 0,
alpha = level_GED_alpha,
beta = level_GED_beta) #What's the variance of this sum?
level_shock_mean <- mu_eps_star
level_shock_var <- ((level_GED_alpha)**2) * gamma(3/level_GED_beta) / (gamma(1/level_GED_beta)) + # https://search.r-project.org/CRAN/refmans/gnorm/html/gnorm.html
(sigma_x**2) * (sigma_eps_star**2)
}
else {level_shock_vec[i] <- rnorm(1, 0, sigma_GARCH_innov); level_shock_mean <- 0; level_shock_var <- sigma_GARCH_innov**2}
#Vol model
if (vol_model == 'M1'){
#Create volatility shock w*
vol_shock_vec[i] <- rnorm(1, mu_omega_star, vol_shock_sd)
vol_shock_mean <- vol_shock_multiplier * mu_omega_star
vol_shock_var <- (vol_shock_multiplier**2) * vol_shock_sd**2
shock_indicator <- c(
rep(0, shock_time_vec[i]),
rep(vol_shock_vec[i], vol_shock_length),
rep(0, Tee[i] - shock_time_vec[i] - vol_shock_length))
#Now add the design matrix to the list X
X[[i]] <- cbind(VAR_process, shock_indicator)
#Create GARCH model with shock(s)
GARCH_innov_vec <- c(
rnorm(shock_time_vec[i], 0, sigma_GARCH_innov),
level_shock_vec[i],
rnorm(Tee[i] - shock_time_vec[i] - 1, 0, sigma_GARCH_innov))
Y[[i]] <- garchxSim(Tee[i], arch = arch_param, garch = garch_param,
xreg =  as.matrix( X[[i]][,(p+1)] ),
innovations = GARCH_innov_vec, verbose = TRUE)
}
else if (vol_model == 'M2') {
vol_shock_vec[i] <- rnorm(1, mu_omega_star, vol_shock_sd)
as.numeric(as.matrix(VAR_process[shock_time_vec[i],])) %*% rnorm(p,M2_mu_omega_star,sigma_eps_star)
#What's the variance of this sum?
vol_shock_mean <- vol_shock_multiplier * mu_omega_star
vol_shock_var <- (vol_shock_multiplier**2) * vol_shock_sd**2 + (sigma_x**2) * (sigma_eps_star**2)
shock_indicator <- c(
rep(0, shock_time_vec[i]),
rep(vol_shock_vec[i], vol_shock_length),
rep(0, Tee[i] - shock_time_vec[i] - vol_shock_length))
#Now add the design matrix to the list X
X[[i]] <- cbind(VAR_process, shock_indicator)
#Create GARCH model with shock(s)
GARCH_innov_vec <- c(
rnorm(shock_time_vec[i], 0, sigma_GARCH_innov),
level_shock_vec[i],
rnorm(Tee[i] - shock_time_vec[i] - 1, 0, sigma_GARCH_innov))
Y[[i]] <- garchxSim(Tee[i], arch = arch_param, garch = garch_param,
xreg =  as.matrix( X[[i]][,(p+1)] ),
innovations = GARCH_innov_vec, verbose = TRUE)
}
else {
#Create volatility shock w*
vol_shock_vec[i] <- rnorm(1, 0, sigma_GARCH_innov)
vol_shock_mean <- 0
vol_shock_var <- 0
#Now add the design matrix to the list X
X[[i]] <- cbind(VAR_process)
#Create GARCH model with shock(s)
GARCH_innov_vec <- rnorm(Tee[i], 0, sigma_GARCH_innov)
Y[[i]] <- garchxSim(Tee[i], arch = arch_param, garch = garch_param,
innovations = GARCH_innov_vec, verbose = TRUE)
} #end conditionals that create vol shocks
T_star_plus_1_return_vec[i] <- Y[[i]][,1][shock_time_vec[1]+1,]
} #end loop for n+1 series
## Compute summary statistics for output
level_shock_kurtosis <- gamma(5/level_GED_beta)*gamma(1/level_GED_beta)/( (gamma(3/level_GED_beta))**2 ) - 3 #https://en.wikipedia.org/wiki/Generalized_normal_distribution
vol_shock_kurtosis <- 6 / omega_shape
T_star_sigma <- Y[[1]][,3][shock_time_vec[1],]
T_star_plus_1_sigma <- Y[[1]][,3][shock_time_vec[1]+1,]
T_star_plus_2_sigma <- Y[[1]][,3][shock_time_vec[1]+2,]
T_star_plus_3_sigma <- Y[[1]][,3][shock_time_vec[1]+3,]
##Output
cat('Simulation Summary Data','\n',
'-------------------------------------------------------------\n',
'Donors:', n, '\n',
'Series lengths:', Tee, '\n',
'Shock times:', shock_time_vec, '\n',
'Level Shock at T*+1:', round(level_shock_vec,2), '\n',
'T*+1: Return:', round(T_star_plus_1_return_vec,3), '\n',
'Volatility Shock at T*+1', round(vol_shock_vec,2), '\n',
'\n',
'Volatility of Time Series under Study', '\n',
'-------------------------------------------------------------\n',
'Sigma^2 at T*:', round(T_star_sigma,2), '\n',
'Sigma^2 at T*+1:', round(T_star_plus_1_sigma,2), '\n',
'Sigma^2 at T*+2:', round(T_star_plus_2_sigma,2), '\n',
'Sigma^2 at T*+3:', round(T_star_plus_3_sigma,2), '\n',
'\n',
'Level Shock Moments', '\n',
'-------------------------------------------------------------\n',
'Level Shock mean:', round(level_shock_mean,4), '(equivalent to a', round(100*level_shock_mean,2), '% daily move).', ' \n',
'Level Shock variance:', round(level_shock_var,4), '\n',
'Level Signal to Noise:', abs(round(level_shock_mean / sqrt(level_shock_var),2)) , '\n',
'Level Shock excess kurtosis:', round(level_shock_kurtosis, 2) , '\n',
'\n',
'Vol Shock Moments', '\n',
'-------------------------------------------------------------\n',
'Vol Shock mean:', round(vol_shock_mean,2), ' \n',
'Vol Shock variance:', round(vol_shock_var,4), '\n',
'Vol Signal to Noise:', abs(round(vol_shock_mean / sqrt(vol_shock_var),3)) , '\n',
'Vol Shock excess kurtosis:', round(vol_shock_kurtosis, 2)
)
#Plot the donors
par(mfrow = c(ceiling(sqrt(2*n + 2)), ceiling(sqrt(2*n + 2))))
for (i in 1:(n+1))
{
plot.ts(X[[i]][-c(1:20),], main = paste('Covariates of Donor ', i, sep = ''))
}
#Plot the time series
par(mfrow = c(ceiling(sqrt(n+1)), ceiling(sqrt(n+1))))
for (i in 1:(n+1))
{
plot.ts(Y[[i]][,1], ylim = c(min(Y[[i]][,1])*1.2, max(Y[[i]][,1])*1.2),
main = paste('y_', i, ", GARCH(",arch_param,",",garch_param,")",
"\n level shock = ",
round( level_shock_vec[i],2),
", vol shock = ",
round(vol_shock_vec[i],2),
sep = ''), ylab = 'Daily Log-Return')
abline(v = shock_time_vec[i] + 1, col = 'red')
}
#Plot the volatility series
par(mfrow = c(ceiling(sqrt(n+1)), ceiling(sqrt(n+1))))
for (i in 1:(n+1))
{
plot.ts(Y[[i]][-c(1:20),3], xlim=c(21, Tee[i]), main = paste('Volatility Series of y_', i,
", GARCH(",arch_param,",",garch_param,")",
"\n level shock = ",
round( level_shock_vec[i],2),
", vol shock = ",
round(vol_shock_vec[i],2),
sep = ''), ylab = 'Sigma^2')
abline(v = shock_time_vec[i] + 1, col = 'red')
}
#Items to return in a list
return(list(X,Y,Tee,shock_time_vec))
}
output <- synth_vol_sim(n = 8,
p = 2,
arch_param = c(.2),
garch_param = c(.7),
level_model = c('M1','M2','none')[3],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = 10,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 2,
arch_param = c(.2),
garch_param = c(.7),
level_model = c('M1','M2','none')[2],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = 10,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 2,
arch_param = c(.2),
garch_param = c(.7),
level_model = c('M1','M2','none')[1],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = 10,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 2,
arch_param = c(.2),
garch_param = c(.7),
level_model = c('M1','M2','none')[3],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = 10,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
output <- synth_vol_sim(n = 8,
p = 2,
arch_param = c(.2),
garch_param = c(.7),
level_model = c('M1','M2','none')[3],
vol_model = c('M1','M2','none')[2],
sigma_GARCH_innov = (.007), # this is the sd that goes into rnorm
sigma_x = .008,
shock_time_vec = NULL,
level_shock_length = 1,
vol_shock_length = 1,
a = 90,
b = 150,
mu_eps_star = -.0825,
M2_mu_eps_star = .3,
sigma_eps_star = .001,
mu_omega_star = .8,
M2_mu_omega_star = 2,
vol_shock_multiplier = 1,
vol_shock_sd = .2,
omega_shape = .2, #these are to be deleted
omega_rate = 2, #these are to be deleted
level_GED_alpha = .05 * sqrt(2),
level_GED_beta = 1.8)
